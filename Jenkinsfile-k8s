pipeline {

  agent {
    kubernetes {
      yamlFile 'kaniko-builder.yaml'
    }
  }
  tools {
      jdk 'Java17'
      maven 'Maven3'
    }
  environment {
        APP_NAME = "chainguard-demo-app"
        RELEASE = "1.0.0"
        DOCKER_USER = "bannimal"
        IMAGE_NAME = "${DOCKER_USER}" + "/" + "${APP_NAME}"
        IMAGE_TAG = "${RELEASE}-${BUILD_NUMBER}"
        /* JENKINS_API_TOKEN = credentials("JENKINS_API_TOKEN") */

    }

  stages {

    stage("Cleanup Workspace") {
      steps {
        cleanWs()
      }
    }

    stage("Checkout from SCM"){
      steps {
          git branch: 'test', credentialsId: 'github_pat', url: 'https://github.com/ericbannon/chainguard-ci-demo.git'
            }

        }

    stage("Build Application"){
      steps {
          sh "mvn clean package"
            }

        }

    stage("Test Application"){
      steps {
          sh "mvn test"
            }

        }

    stage("Sonarqube Analysis") {
      steps {
        script {
              withSonarQubeEnv(credentialsId: 'jenkins-sonarqube-token') {
                sh "mvn sonar:sonar"
                    }
                }
            }

        }

    stage("Quality Gate") {
      steps {
          script {
              waitForQualityGate abortPipeline: false, credentialsId: 'jenkins-sonarqube-token'
                }
            }

        }

    stage('Build & Push with Kaniko') {
      steps {
        container(name: 'kaniko', shell: '/busybox/sh') {
          sh '''#!/busybox/sh

            /kaniko/executor --dockerfile `pwd`/Dockerfile --context `pwd` --destination=${IMAGE_NAME}:${IMAGE_TAG} --destination=${IMAGE_NAME}:latest
          '''
        }
      }
    }

     stage('Analyze with grype') {
      steps {
        // run grype with json output, use jq just to get severities, 
        // concatenate all onto one line, if we find High or Critical 
        // vulnerabilities, fail and kill the pipeline
        //
        // set -o pipefail enables the entire command to return the failure 
        // in grype and still get the count of vulnerability types
        // 
        // you can change this from "high" to "critical" if you want to see 
        // the command succeed since pvnovarese/ubuntu_sudo_test doesn't (as 
        // of today) have any critical vulns in it, just high.
        //
        script {
          try {
            // -f critical --> fail if "critical" vulns detected
            // we don't really need to pipe into jq if we're just testing
            // for vulns, but this way we can get some output to provide
            // to devs as feedback.
            //
            sh 'set -o pipefail ; /usr/local/bin/grype -f high -q ${IMAGE_NAME}:${IMAGE_TAG}'
          } catch (err) {
            // if scan fails, clean up (delete the image) and fail the build
            sh """
              echo "Vulnerabilities detected in ${IMAGE_NAME}:${IMAGE_TAG}, cleaning up and failing build."
              exit 1
            """
          } // end try/catch
        } // end script
      } // end steps
    } // end stage "analyze with grype"

     stage('Re-tag as prod and push stable image to registry') {
      steps {
        container(name: 'kaniko', shell: '/busybox/sh') {
          sh '''#!/busybox/sh

            /kaniko/executor --dockerfile `pwd`/Dockerfile --context `pwd` --destination=${IMAGE_NAME}:${IMAGE_TAG}-prod --destination=${IMAGE_NAME}:latest
          '''
      } // end steps
    } // end stage "retag as prod"

  } // end stages

  }
}